
========================================================================
                       개선안: Path 저장 최적화
========================================================================

1. 청크 트리 + 해시 테이블
------------------------------------------------------------------------

고정 크기 청크(크기=2)와 해시 테이블로 경로 공유 극대화.

1.1 해시 키 구조
------------------------------------------------------------------------

    Hash Key: (parent_chunk, [value, _])
      - parent_chunk: 부모 청크 (첫 청크면 NULL)
      - value: 현재 값
      - RC: Reference Count (공유 경로 수)


1.2 예제: 3라운드 실행
------------------------------------------------------------------------

ROUND 1: A, B, B 입력

    Hash Table:
    ┌──────────────────────────────────────┐
    │ Chunk1 (NULL, [A,_])    RC:1         │
    │ Chunk2 (NULL, [B,_])    RC:2         │
    └──────────────────────────────────────┘

    Active Paths: 3
      - Path 1:   [A]  -> Chunk1
      - Path 2,3: [B]  -> Chunk2 (공유)

    Chunk Tree:
      Chunk1[A,_]    Chunk2[B,_]
         RC:1           RC:2
           ^            ^  ^
          P1           P2  P3


ROUND 2: A에 A,C,C / B에 D 입력

    Hash Table:
    ┌──────────────────────────────────────┐
    │ Chunk1 (NULL, [A,_])    RC:0 Freed   │
    │ Chunk2 (NULL, [B,_])    RC:0 Freed   │
    │ Chunk3 (NULL, [A,A])    RC:1         │
    │ Chunk4 (NULL, [A,C])    RC:2         │
    │ Chunk5 (NULL, [B,D])    RC:2         │
    └──────────────────────────────────────┘

    Active Paths: 5
      - Path 1:   [A,A]  -> Chunk3
      - Path 3,4: [A,C]  -> Chunk4 (공유)
      - Path 2,5: [B,D]  -> Chunk5 (공유)

    Chunk Tree:
      Chunk3[A,A]   Chunk4[A,C]   Chunk5[B,D]
         RC:1          RC:2          RC:2
           ^           ^  ^          ^  ^
          P1          P3  P4        P2  P5


ROUND 3: AA에 A,D / AC에 A,C / BD에 E,E 입력

    Hash Table:
    ┌──────────────────────────────────────┐
    │ Chunk3 (NULL, [A,A])     RC:2        │
    │ Chunk4 (NULL, [A,C])     RC:2        │
    │ Chunk5 (NULL, [B,D])     RC:1        │
    │ Chunk1 (Chunk3, [A,_])   RC:1  Reuse │
    │ Chunk2 (Chunk3, [D,_])   RC:1  Reuse │
    │ Chunk6 (Chunk4, [A,_])   RC:2        │
    │ Chunk7 (Chunk4, [C,_])   RC:2        │
    │ Chunk8 (Chunk5, [E,_])   RC:4        │
    └──────────────────────────────────────┘

    Active Paths: 10
      - No Path:       [A,A]    -> Chunk3 (중간 노드)
      - No Path:       [A,C]    -> Chunk4 (중간 노드)
      - No Path:       [B,D]    -> Chunk5 (중간 노드)
      - Path 1:        [A,A,A]  -> Chunk3 -> Chunk1
      - Path 6:        [A,A,D]  -> Chunk3 -> Chunk2
      - Path 3,4:      [A,C,A]  -> Chunk4 -> Chunk6 (공유)
      - Path 7,8:      [A,C,C]  -> Chunk4 -> Chunk7 (공유)
      - Path 2,5,9,10: [B,D,E]  -> Chunk5 -> Chunk8 (공유)

    Chunk Tree:
          Chunk3[A,A]         Chunk4[A,C]        Chunk5[B,D]
             RC:2                RC:2               RC:1
            /    \              /    \                |
      Chunk1    Chunk2    Chunk6    Chunk7          Chunk8
       [A,_]     [D,_]     [A,_]     [C,_]           [E,_]
       RC:1      RC:1      RC:2      RC:2            RC:4
         ^         ^       ^  ^      ^  ^            ^^^^
        P1        P6      P3 P4     P7 P8         P2,P5,P9,P10

    Summary:
      Total Chunks: 8 (10개 경로를 8개 청크로 표현)
      Reused: Chunk1, Chunk2 (FreeList에서 재활용)
      최대 공유: Chunk8 RC:4 (4개 경로가 단일 청크 공유)


1.3 동작 원리
------------------------------------------------------------------------

    값 추가 시:
      1. hash(prev_chunk, [new_value, _]) 조회
      2. 존재하면: RC 증가, 기존 청크 재사용
      3. 없으면: 새 청크 생성, 해시 테이블 등록

    Fork 시:
      - 부모 청크 동일 + 새 값 동일 -> 자동 공유
      - RC만 증가, 메모리 할당 없음

    GC:
      - RC=0이 되면 청크 해제
      - 부모 청크의 RC도 감소 (재귀적)


1.4 장단점
------------------------------------------------------------------------

    장점:
      - 메모리 효율: 동일 경로 자동 공유 (10경로 -> 8청크)
      - Fork 비용 O(1): RC 증가만으로 분기
      - 경로 복사/수정 O(1): 앞부분은 포인터로 공유, 뒤만 변경
      - 고정 크기 메모리 풀 사용 가능

    단점:
      - 전체 경로 조회 시 트리 역순회 필요
      - 해시 테이블 오버헤드

