
========================================================================
                  RPR NFA 패턴 매칭 시스템 개요
========================================================================

0. 모티베이션과 접근법
------------------------------------------------------------------------

0.1 배경: PostgreSQL RPR 패치의 한계

    PostgreSQL의 기존 RPR 구현 (RPR-base 브랜치)은 정규식 기반 접근법을
    사용합니다:

    ┌─────────────────────────────────────────────────────────────────┐
    │  기존 구현 방식 (정규식 기반)                                   │
    ├─────────────────────────────────────────────────────────────────┤
    │                                                                 │
    │  1. 각 행에서 모든 DEFINE 조건 평가                             │
    │     → 매칭되는 변수를 알파벳으로 인코딩 (a, b, c, ...)          │
    │                                                                 │
    │  2. 인코딩된 문자열 누적                                        │
    │     "aabbc" (A 매칭, A 매칭, B 매칭, B 매칭, C 매칭)            │
    │                                                                 │
    │  3. PATTERN을 정규식으로 변환                                   │
    │     PATTERN (A+ B+ C) → "^a+b+c"                                │
    │                                                                 │
    │  4. PostgreSQL regex 엔진으로 매칭                              │
    │     pg_regexec(&preg, encoded_str, ...)                         │
    │                                                                 │
    └─────────────────────────────────────────────────────────────────┘

    한계점 (nodeWindowAgg.c 분석 기반):

    ┌──────────────────┬──────────────────────────────────────────────┐
    │ 한계             │ 원인                                         │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 조합 폭발        │ generate_patterns()에서 행별 카테시안 곱     │
    │ O(V^N)           │ 3변수 20행 → 34억 조합                       │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 변수 26개 제한   │ a-z 알파벳 인코딩 (NUM_ALPHABETS=26)         │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ Lexical Order    │ DEFINE 선언 순서로 인코딩, PATTERN 대안 순서 │
    │ 미보장           │ 무시됨. (B|A) 패턴에서 A가 먼저 인코딩       │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ RELUCTANT 미지원 │ greedy 플래그만 존재, 최단 매칭 로직 없음    │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ MEASURES 미구현  │ 재스캔 기반 우회, 증분 집계 없음             │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 매칭 실패 시     │ 중간 상태 미유지. Row N에서 실패 시          │
    │ O(N²) 재시도     │ Row K+1부터 처음부터 재시도                  │
    └──────────────────┴──────────────────────────────────────────────┘


0.2 접근법: StreamingNFA 기반 스트리밍 매칭

    Apache Flink CEP와 유사한 NFA 기반 접근법을 채택합니다:

    ┌─────────────────────────────────────────────────────────────────┐
    │  NFA 기반 접근법                                                │
    ├─────────────────────────────────────────────────────────────────┤
    │                                                                 │
    │  핵심 아이디어:                                                 │
    │    - 패턴을 플랫 배열(PatternElement[])로 컴파일                │
    │    - 각 행 처리 시 상태 전이만 수행 (정규식 매칭 없음)          │
    │    - 동일 상태는 Merge하여 중복 계산 방지                       │
    │                                                                 │
    │  시간 복잡도: O(N × S × E)                                      │
    │    N: 입력 행 수                                                │
    │    S: 동시 활성 상태 수 (Merge로 제한됨)                        │
    │    E: 패턴 요소 수                                              │
    │                                                                 │
    └─────────────────────────────────────────────────────────────────┘

    한계점 해결:

    ┌──────────────────┬──────────────────────────────────────────────┐
    │ 기존 한계        │ Streaming NFA 접근법으로 해결                │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 조합 폭발        │ 상태 전이 기반, 동일 상태 Merge              │
    │ O(V^N)           │ → O(N×S×E), S는 패턴 크기에 비례             │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 변수 26개 제한   │ 정수 varId 사용, 필요 시 크기 조정 가능      │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ Lexical Order    │ PATTERN 순서대로 #ALT 분기 생성              │
    │ 미보장           │ → 대안 순서가 paths[][] 순서로 보존          │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ RELUCTANT 미지원 │ 자체 NFA 구현으로 최단/최장 매칭 제어 가능   │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ MEASURES 미구현  │ 증분 집계로 SUM, COUNT 등 실시간 계산        │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 매칭 실패 시     │ 다중 Context 동시 유지                       │
    │ O(N²) 재시도     │ → 각 시작점의 상태를 병렬 추적, O(N)         │
    └──────────────────┴──────────────────────────────────────────────┘

    새로운 장점:

    ┌──────────────────┬──────────────────────────────────────────────┐
    │ 장점             │ 설명                                         │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ ALL ROWS 모드    │ 모든 가능한 매칭 경로를 동시 추적            │
    │                  │ → 각 Context가 독립적으로 분기 및 완료       │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ Context 흡수     │ 동일 상태 도달 시 Context 병합               │
    │                  │ → 중복 계산 제거, 메모리 효율                │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 증분 집계        │ 매칭 중 SUM, COUNT 등 실시간 계산            │
    │                  │ → 완료 후 재스캔 불필요                      │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ 플랫 배열 구조   │ states[], contexts[] 연속 메모리 배치        │
    │                  │ → 캐시 지역성 우수, 포인터 추적 없음         │
    ├──────────────────┼──────────────────────────────────────────────┤
    │ Path 공유        │ 청크 트리 + 해시 테이블로 동일 경로 공유     │
    │                  │ → 분기 시 O(1) 참조, 메모리 중복 제거        │
    └──────────────────┴──────────────────────────────────────────────┘


0.3 Flink와의 차이: History 제거

    ┌─────────────────────────────────────────────────────────────────┐
    │  Flink CEP (스트리밍 환경)          PostgreSQL (배치 환경)      │
    ├─────────────────────────────────────────────────────────────────┤
    │                                                                 │
    │  원본 데이터가 흘러감               머티리얼라이즈된 데이터     │
    │  → 재접근 불가                      → 언제든 재스캔 가능        │
    │  → History에 행 데이터 저장         → History 불필요            │
    │  → 포인터 트리 + 참조 카운트        → match_start/end만 저장    │
    │                                                                 │
    │  Fork 시: 포인터 복사 O(1)          Fork 시: counts[] 복사      │
    │  MEASURES: History 역추적           MEASURES: 범위 재스캔       │
    │                                                                 │
    └─────────────────────────────────────────────────────────────────┘

    본 구현의 선택:
      - 증분 집계 (Incremental Aggregation) 채택
      - 매칭 중에 SUM, COUNT 등을 실시간 계산
      - History 포인터 없이 aggregate 값만 유지
      - 경로 정보는 paths[][]에 변수ID 배열로 저장


0.4 설계 목표

    ┌──────────────┬──────────────────────────────────────────────────┐
    │ 목표         │ 설명                                             │
    ├──────────────┼──────────────────────────────────────────────────┤
    │ 선형 복잡도  │ O(N×S×E), 조합 폭발 없음                         │
    │ 표준 준수    │ SQL:2016 RPR 시맨틱 (GREEDY, RELUCTANT, SKIP)    │
    │ 확장성       │ MEASURES, SUBSET 등 향후 확장 가능               │
    │ 단순성       │ 플랫 배열 패턴, 명확한 상태 전이 규칙            │
    └──────────────┴──────────────────────────────────────────────────┘


0.5 Path 저장 최적화

    Context 분기 시 경로(paths[][])가 복제되면 메모리 폭발 위험.
    청크 트리 + 해시 테이블로 동일 경로 공유:

    ┌─────────────────────────────────────────────────────────────────┐
    │  청크 트리 구조                                                 │
    ├─────────────────────────────────────────────────────────────────┤
    │                                                                 │
    │  Chunk: 고정 크기(2) 배열 + 부모 포인터 + 참조 카운트           │
    │                                                                 │
    │  예: [A,A,C,D]와 [A,A,C,E] 두 경로                              │
    │                                                                 │
    │      Chunk1[A,A] ← Chunk2[C,D]  (Path1)                         │
    │         RC:2    ↖                                               │
    │                   Chunk3[C,E]  (Path2)                          │
    │                                                                 │
    │      → 부모 청크(Chunk1) 공유, 분기점부터만 새 청크 생성        │
    │                                                                 │
    │  해시 테이블: (parent, values) → 동일 청크 재사용               │
    │                                                                 │
    └─────────────────────────────────────────────────────────────────┘


1. 시스템 구조
------------------------------------------------------------------------

┌──────────────────────────────────────────────────────────────────────┐
│                        처리 파이프라인                               │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  패턴 문자열      Parser        Pattern        Executor        결과  │
│  "A+ B | C"  ───▶  (AST)  ───▶ (elements) ───▶ (Contexts) ───▶ 매칭  │
│                                                                      │
│  ┌──────────────────┐  ┌───────────────────┐  ┌───────────────────┐  │
│  │      Parser      │  │      Context      │  │     Executor      │  │
│  │                  │  │                   │  │                   │  │
│  │  토큰화          │  │  MatchState       │  │  NFAExecutor      │  │
│  │  AST 생성        │  │  MatchContext     │  │  다중 Context     │  │
│  │  최적화          │  │  상태 전이        │  │  흡수/SKIP        │  │
│  │  컴파일          │  │  Greedy/Reluctant │  │  출력 관리        │  │
│  └──────────────────┘  └───────────────────┘  └───────────────────┘  │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘


2. 문서 구조
------------------------------------------------------------------------

┌──────────────┬────────────────────────────────────────────────────┐
│ Parser       │ 패턴 문자열 → PatternElement[] 변환                │
│              │  - 토크나이저: 문자열 → 토큰                       │
│              │  - 파서: 토큰 → AST                                │
│              │  - 최적화: AST 단순화                              │
│              │  - 컴파일: AST → PatternElement[]                  │
├──────────────┼────────────────────────────────────────────────────┤
│ Context      │ 단일 Context 내부 동작                             │
│              │  - MatchState: 현재 위치 + 카운터 + 경로           │
│              │  - MatchContext: State들의 집합                    │
│              │  - 상태 전이: 변수 매칭, #ALT, #END, #FIN 처리     │
│              │  - Greedy/Reluctant 수량자 동작                    │
├──────────────┼────────────────────────────────────────────────────┤
│ Executor     │ 다중 Context 관리                                  │
│              │  - NFAExecutor: 메인 실행 엔진                     │
│              │  - Context 생성/흡수/제거                          │
│              │  - SKIP 모드 (PAST LAST / TO NEXT)                 │
│              │  - 출력 행 수 (ONE ROW / ALL ROWS)                 │
├──────────────┼────────────────────────────────────────────────────┤
│ Improvements │ 향후 개선안                                        │
│              │  - Path 저장 최적화 (청크 트리 + 해시 테이블)      │
└──────────────┴────────────────────────────────────────────────────┘


3. 주요 자료구조
------------------------------------------------------------------------

3.1 Pattern
    컴파일된 패턴 전체.

    필드:
      - maxDepth: 최대 중첩 깊이
      - elements[]: PatternElement 배열
      - variables[]: 변수명 배열 (variables[varId] → 변수명)
      - firstMatchIsGreedy: 첫번째 매칭이 Greedy인지 (Context absorption 조건)

3.2 PatternElement
    컴파일된 패턴의 단일 요소.

    필드:
      - varId: 변수 식별자 또는 특수 마커 (0+ 변수, 음수 특수)
      - reluctant: 플래그 (true면 최단, false면 최장)
      - min, max: 수량자 범위
      - depth: 중첩 깊이
      - next: 다음 요소 인덱스
      - jump: 대안/반복 점프 대상

3.3 MatchState
    NFA 실행 중 단일 상태.

    필드:
      - elementIndex: 현재 PatternElement 위치
      - counts[]: 깊이별 반복 카운터
      - summaries[]: Summary 배열 (생성 순서 유지)

    상태 동등성: elementIndex + counts[] 일치 시 동일 상태
    Merge 시 summaries는 병합됨

3.4 Summary
    Aggregate 값과 경로 정보.

    필드:
      - aggregates{}: 증분 집계값 (SUM, COUNT, FIRST, LAST, MIN, MAX)
      - paths[][]: 매칭된 변수 경로들 (생성 순서 유지)

    Merge 규칙:
      - aggregate 값 동일 시 summary Merge → paths 병합
      - summaries[0].paths[0] = Lexical Order 우선 경로

3.5 MatchContext
    동일 시작점의 State 집합.

    필드:
      - matchStart: 매칭 시작 행 (고유 식별자)
      - matchEnd: 매칭 종료 행 (matchedState 갱신 시 currentRow 저장)
      - states[]: 활성 State들 (생성 순서 유지, 모든 분기 경로)
      - matchedState: MatchState | null (Greedy 폴백용)

3.6 NFAExecutor
    메인 실행 엔진.

    필드:
      - pattern: 컴파일된 패턴
      - contexts[]: 활성 Context들 (생성 순서 유지)
      - completedContexts[]: 완료 Context들 (start 순 정렬, 선행 대기)
      - skipMode: PAST_LAST / TO_NEXT
      - currentRow: 현재 처리 중인 행 번호
      - history[]: 행별 실행 스냅샷 (디버깅용)


4. 실행 흐름
------------------------------------------------------------------------

┌─────────────────────────────────────────────────────────────────────┐
│                         행 단위 처리                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  FOR EACH row IN data:                                              │
│      │                                                              │
│      ├─▶ 1. tryStartNewContext(row)                                 │
│      │       └─ 새 매칭 시작 가능하면 Context 생성                  │
│      │                                                              │
│      ├─▶ 2. FOR EACH context:                                       │
│      │       └─ processContext(context, row)                        │
│      │           └─ 상태 전이 + aggregate 증분 계산                 │
│      │                                                              │
│      ├─▶ 3. mergeStates() + absorbContexts()                        │
│      │       ├─ State Merge (elementIndex+counts 동일)              │
│      │       ├─ Summary Merge (aggregate 동일 → paths 병합)         │
│      │       └─ 후발 Context를 선발에 흡수                          │
│      │                                                              │
│      ├─▶ 4. 사망/완료 Context 제거                                  │
│      │                                                              │
│      └─▶ 5. emitRows()                                              │
│              ├─ contexts[1+] 완료 → completedContexts에 대기        │
│              └─ contexts[0] 완료 → 즉시 emit, 대기열 처리           │
│                  └─ start < contexts[0].start인 항목 순회           │
│                      ├─ PAST LAST: start <= 직전 end면 폐기, 계속   │
│                      └─ TO NEXT: end >= ctx[0].start → 중단 (대기)  │
│                                  end < ctx[0].start → emit          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘


5. 핵심 개념
------------------------------------------------------------------------

5.1 상태 전이

    변수 요소:    조건 참이면 next로 이동, paths에 추가
    #ALT:         모든 대안으로 분기 (next, jump 체인)
    #END:         카운터 검사 후 반복(jump) 또는 탈출(next)
    #FIN:         매칭 완료

5.2 매칭 모드 (3개 축)

    ┌──────────────────────────────────────────────────────────────────┐
    │  [축 1] 출력 행 수:   ONE ROW / ALL ROWS                         │
    │  [축 2] 수량자 탐욕성: GREEDY / RELUCTANT                        │
    │  [축 3] SKIP 옵션:    PAST LAST / TO NEXT                        │
    └──────────────────────────────────────────────────────────────────┘

    출력 행 수:
      - ONE ROW:   paths[0] 출력 (Lexical Order 우선 경로)
      - ALL ROWS:  모든 paths 출력

    수량자 탐욕성:
      - GREEDY:    최장 매칭 우선, 완료를 보존하고 계속 진행
      - RELUCTANT: 최단 매칭 우선, 완료 즉시 반환

    SKIP 옵션:
      - PAST LAST: 여러 Context 활성 가능, emit 시 중첩 폐기
      - TO NEXT:   매 행마다 시작 가능, 중첩 매칭 허용

5.3 Merge 규칙

    State Merge (Context 내부):
      - 조건: elementIndex + counts[] 동일
      - 동작: summaries 병합 (생성 순서 유지)
      - 결과: 동일 위치의 State 수 감소, 중복 계산 방지

    Summary Merge (State 내부):
      - 조건: aggregates{} 값 동일
      - 동작: paths 병합 (생성 순서 유지)
      - 결과: summaries[0].paths[0] = Lexical Order 우선 경로

5.4 Context 흡수

    조건: 패턴의 첫번째 매칭이 Greedy (max=∞ AND reluctant=false)
          (동일 elementIndex AND 선발.counts >= 후발.counts)
    동작: 후발 Context 제거
    결과: 선발이 더 긴 매칭 계속, 중복 계산 방지

5.5 emit 흐름

    - contexts[0] 완료 → 즉시 emit
    - contexts[1+] 완료 → completedContexts에 대기
    - contexts[0] emit 후 대기열 처리 (start 순):
        1. start >= contexts[0].start → 중단 (아직 emit 자격 없음)
        2. PAST LAST: start <= 직전 emit의 end → 폐기, 다음 항목 계속
        3. TO NEXT: 블럭 없음 (중첩 허용) → emit, 다음 항목 계속


6. 모듈 간 의존성
------------------------------------------------------------------------

  Parser ────────────────────────────────────────────────────────────
    출력: PatternElement[]
    → Context: PatternElement를 State가 참조
    → Executor: pattern 필드로 전달

  Context ───────────────────────────────────────────────────────────
    입력: PatternElement[] (읽기 전용)
    출력: MatchContext (완료/진행 상태)
    → Executor: processContext()에서 State 전이 수행

  Executor ──────────────────────────────────────────────────────────
    입력: Pattern, 데이터 행
    내부: Context 생성/관리
    출력: 매칭 결과 (completedContexts)
