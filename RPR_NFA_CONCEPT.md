# RPR STREAM NFA 개념 설계서

**Author:** Henson Choi
**Email:** assam258@gmail.com
**Date:** 2025-12-28

---

## 1. 개요

### 1.1 목적

SQL Row Pattern Recognition (RPR)의 PATTERN 절을 NFA로 구현하기 위한 개념 설계입니다.

### 1.2 설계 목표

| 목표 | 설명 |
|------|------|
| **성능** | Flink 수준의 효율성 |
| **단순성** | 플랫 배열로 캐시 효율적 |
| **안전성** | 상태/컨텍스트 수 제한 |
| **확장성** | RELUCTANT, PERMUTE 등 확장 가능 |

### 1.3 핵심 아이디어

```
┌───────────────────────────────────────────────────────────────────┐
│                        NFAExecutor                                │
│  ┌─────────────────────────────────────────────────────┐          │
│  │ Pattern (플랫 배열)                                 │          │
│  │  [0]A → [1]B+ → [2]C* → 종료                        │          │
│  └─────────────────────────────────────────────────────┘          │
│                                                                   │
│  ┌─ Context 0 (start: row 0) ──┐  ┌─ Context 1 (start: row 1) ─┐  │
│  │  match_start: 0             │  │  match_start: 1            │  │
│  │  State A                    │  │  State B                   │  │
│  │  State B                    │  └────────────────────────────┘  │
│  │  State C                    │                                  │
│  └─────────────────────────────┘                                  │
└───────────────────────────────────────────────────────────────────┘
```

### 1.4 History란?

스트리밍 패턴 매칭 시스템(Apache Flink CEP 등)에서 **History**는 매칭 과정에서
어떤 행이 어떤 패턴 변수에 할당되었는지를 추적하는 자료구조입니다.

```
┌────────────────────────────────────────────────────────────────────┐
│  History (Flink SharedBuffer 스타일)                               │
│                                                                    │
│    매칭 경로를 포인터 트리로 저장:                                 │
│                                                                    │
│    [row0:A] ──┬──→ [row1:B] ──→ [row2:B] ──→ [row3:C]  (경로 1)    │
│               │                                                    │
│               └──→ [row1:B] ──→ [row2:C]               (경로 2)    │
│                                                                    │
│    본질: 스트리밍 환경에서 원본 데이터에 재접근 불가하므로         │
│          Java 객체로 행 데이터를 복제하여 저장하는 머티리얼라이즈  │
│                                                                    │
│    문제점:                                                         │
│    - 행당 ~40바이트 오버헤드 (Java 객체 헤더, 포인터 등)           │
│    - 참조 카운트 기반 GC 필요                                      │
│    - 포인터 추적으로 캐시 비효율                                   │
└────────────────────────────────────────────────────────────────────┘
```

### 1.5 History가 필요 없는 이유

```
┌────────────────────────────────────────────────────────────────────┐
│  Flink CEP (스트리밍):                                             │
│    - 원본 데이터가 흘러가버림 → 재접근 불가                        │
│    - 어쩔 수 없이 History로 행 데이터 복제 저장                    │
│    - Java 객체 오버헤드 + 포인터 트리 복잡성                       │
│                                                                    │
│  PostgreSQL (배치):                                                │
│    - 윈도우 함수 특성상 파티션 데이터를 tuplestore에 머티리얼라이즈│
│    - 원본 데이터에 언제든 재접근 가능                              │
│    - match_start, match_end만 있으면 재스캔으로 모든 계산 가능     │
│    - History 불필요 → 구현 단순화                                  │
└────────────────────────────────────────────────────────────────────┘
```

---

## 2. 자료구조

### 2.1 Pattern (패턴)

파싱된 PATTERN 절을 플랫 배열로 표현합니다.

```
┌─────────────────────────────────────────────────────────┐
│ Pattern                                                 │
├─────────────────────────────────────────────────────────┤
│ num_elements: 4          (패턴 요소 개수)               │
│ num_vars: 3              (변수 개수: A, B, C)           │
│ max_depth: 1             (최대 중첩 깊이)               │
├─────────────────────────────────────────────────────────┤
│ elements[]:                                             │
│   [0] PatternElement (A)                                │
│   [1] PatternElement (B+)                               │
│   [2] PatternElement (C*)                               │
│   [3] PatternElement (종료)                             │
└─────────────────────────────────────────────────────────┘
```

### 2.2 PatternElement (패턴 요소)

각 패턴 요소의 구조입니다.

```
┌─────────────────────────────────────────────────────────┐
│ PatternElement                                          │
├─────────────────────────────────────────────────────────┤
│ var_index    : 변수 인덱스 (0~N-1), 그룹종료는 -1       │
│ depth        : 중첩 깊이 (0 = 최외곽)                   │
│ min          : 최소 반복 횟수                           │
│ max          : 최대 반복 횟수 (무한 = INT64_MAX)        │
│ next         : 완료 시 다음 요소 (-1 = 패턴 종료)       │
│ jump         : 반복 시 점프 위치 (-1 = 점프 없음)       │
├─────────────────────────────────────────────────────────┤
│ [사전계산]                                              │
│ can_skip         : min == 0 여부                        │
│ can_complete_from: 여기서 끝까지 모두 스킵 가능 여부    │
│ min_rows_to_end  : 완료까지 필요한 최소 행 수           │
└─────────────────────────────────────────────────────────┘
```

**수량자 표현:**

| 표기법 | min | max | 설명 |
|--------|-----|-----|------|
| A | 1 | 1 | 정확히 1회 |
| A? | 0 | 1 | 0 또는 1회 |
| A* | 0 | ∞ | 0회 이상 |
| A+ | 1 | ∞ | 1회 이상 |
| A{2,5} | 2 | 5 | 2~5회 |

### 2.3 MatchState (매칭 상태) - 단순화됨

NFA의 런타임 상태입니다. **History 포인터가 제거되었습니다.**

```
┌─────────────────────────────────────────────────────────┐
│ MatchState                                              │
├─────────────────────────────────────────────────────────┤
│ element_index : 현재 패턴 위치 (-1 = 완료)              │
│ hash          : 동일 상태 탐색용 해시값 (Merge 최적화)  │
│ counts[]      : 깊이별 반복 횟수 [max_depth + 1]        │
└─────────────────────────────────────────────────────────┘

** History 필드 제거됨 **
- match_start/match_end로 충분
- 매칭 완료 후 재스캔으로 집계 계산
```

**상태 동등성:**
- 두 상태가 동일 = `element_index`와 `counts[]`가 모두 같음
- 해시로 빠르게 후보 탐색, 전체 비교로 동일 여부 확인

### 2.4 MatchContext (매칭 컨텍스트)

동일 시작점의 상태들을 그룹화합니다.

```
┌─────────────────────────────────────────────────────────┐
│ MatchContext                                            │
├─────────────────────────────────────────────────────────┤
│ match_start          : 매칭 시작 행                     │
│ match_end            : 매칭 종료 행 (완료 시 설정)      │
│ last_empty_match_row : 마지막 빈 매칭 행 (-1 = 없음)    │
│ num_states           : 활성 상태 개수                   │
│ states               : 상태 연결 리스트 ─────┐          │
└──────────────────────────────────────────────│──────────┘
                                               ▼
                              MatchState → MatchState → ...
```

### 2.5 NFAExecutor (실행기)

전체 NFA 실행을 관리합니다.

```
┌─────────────────────────────────────────────────────────┐
│ NFAExecutor                                             │
├─────────────────────────────────────────────────────────┤
│ pattern       : Pattern 포인터                          │
│ current_row   : 현재 처리 중인 행                       │
│ contexts      : 활성 컨텍스트 리스트 ─────┐             │
│ num_contexts  : 컨텍스트 개수             │             │
│ skip_option   : SKIP PAST LAST ROW 등     │             │
│ stats         : 실행 통계                 │             │
│ pool          : 상태 풀 (재사용)          │             │
└───────────────────────────────────────────│─────────────┘
                                            ▼
                        Context 0 → Context 1 → Context 2 → ...
```

---

## 3. 패턴 파싱 예제

### 3.1 단순 시퀀스: `PATTERN (A B+ C*)`

```
패턴 요소 배열:
┌─────┬───────────┬───────┬─────┬─────┬──────┬──────┐
│ idx │ var_index │ depth │ min │ max │ next │ jump │
├─────┼───────────┼───────┼─────┼─────┼──────┼──────┤
│  0  │     0 (A) │   0   │  1  │  1  │   1  │  -1  │
│  1  │     1 (B) │   0   │  1  │  ∞  │   2  │  -1  │
│  2  │     2 (C) │   0   │  0  │  ∞  │  -1  │  -1  │
└─────┴───────────┴───────┴─────┴─────┴──────┴──────┘

전이 다이어그램:
    A(1회)      B(1회 이상)    C(0회 이상)
  ┌───────┐   ┌───────┐      ┌───────┐
  │  [0]  │──▶│  [1]  │─────▶│  [2]  │──▶ 종료
  └───────┘   └───┬───┘      └───┬───┘
                  │              │
                  └──────────────┘
                    (자기 반복)
```

### 3.2 대안선택: `PATTERN (A | B | C)`

```
패턴 요소 배열:
┌─────┬───────────┬───────┬─────┬─────┬──────┬──────┐
│ idx │ var_index │ depth │ min │ max │ next │ jump │
├─────┼───────────┼───────┼─────┼─────┼──────┼──────┤
│  0  │     0 (A) │   1   │  1  │  1  │   3  │  -1  │
│  1  │     1 (B) │   1   │  1  │  1  │   3  │  -1  │
│  2  │     2 (C) │   1   │  1  │  1  │   3  │  -1  │
│  3  │    -1     │   0   │  1  │  1  │  -1  │  -1  │  ← 그룹 종료
└─────┴───────────┴───────┴─────┴─────┴──────┴──────┘

전이 다이어그램:
            ┌───────┐
       ┌───▶│ [0] A │───┐
       │    └───────┘   │
       │    ┌───────┐   │    ┌───────┐
  시작─┼───▶│ [1] B │───┼───▶│ [3]   │──▶ 종료
       │    └───────┘   │    │ 그룹  │
       │    ┌───────┐   │    │ 종료  │
       └───▶│ [2] C │───┘    └───────┘
            └───────┘

** 모든 대안을 동시에 시도하고, 매칭되는 것만 진행 **
```

### 3.3 그룹 반복: `PATTERN ((A B){2,3} C)`

```
패턴 요소 배열:
┌─────┬───────────┬───────┬─────┬─────┬──────┬──────┐
│ idx │ var_index │ depth │ min │ max │ next │ jump │
├─────┼───────────┼───────┼─────┼─────┼──────┼──────┤
│  0  │     0 (A) │   1   │  1  │  1  │   1  │  -1  │
│  1  │     1 (B) │   1   │  1  │  1  │   2  │  -1  │
│  2  │    -1     │   1   │  2  │  3  │   3  │   0  │  ← 그룹 종료
│  3  │     2 (C) │   0   │  1  │  1  │  -1  │  -1  │
└─────┴───────────┴───────┴─────┴─────┴──────┴──────┘

전이 다이어그램:
         ┌────────────────────────┐
         │      jump (반복)       │
         ▼                        │
    ┌───────┐   ┌───────┐   ┌─────┴─┐   ┌───────┐
    │ [0] A │──▶│ [1] B │──▶│ [2]   │──▶│ [3] C │──▶ 종료
    └───────┘   └───────┘   │ 그룹  │   └───────┘
                            │ 종료  │
                            │min:2  │
                            │max:3  │
                            └───────┘
                                │
                          next (진행)

counts[1] = 그룹 완료 횟수:
  - < min(2): 반드시 jump로 반복
  - >= min(2) && < max(3): jump 또는 next 선택 (fork)
  - == max(3): 반드시 next로 진행
```

---

## 4. 상태 관리

### 4.1 상태 Fork

분기가 필요할 때 상태를 복제합니다.

```
Fork 발생 상황:
1. 대안선택에서 여러 대안이 매칭될 때
2. 수량자 범위 내에서 "계속" vs "종료" 선택 시

Fork 전:                    Fork 후:
┌─────────────┐            ┌─────────────┐
│   State A   │            │   State A   │ (원본)
│ elem: 1     │     ──▶    │ elem: 1     │
│ counts:[2]  │            │ counts:[2]  │
└─────────────┘            └─────────────┘
                           ┌─────────────┐
                           │   State B   │ (복제)
                           │ elem: 2     │
                           │ counts:[2]  │
                           └─────────────┘
```

**Fork 비용: O(depth)** - counts[] 배열만 복사 (History 없음)

### 4.2 상태 Merge

동일한 상태는 하나만 유지합니다.

```
Merge 조건: element_index와 counts[]가 동일

Merge 전:
┌─────────────┐   ┌─────────────┐
│   State A   │   │   State B   │
│ elem: 2     │   │ elem: 2     │  ← 같은 위치
│ counts:[1]  │   │ counts:[1]  │  ← 같은 카운트
└─────────────┘   └─────────────┘

Merge 후:
┌─────────────┐
│   State A   │  (첫 번째 유지, 패턴 순서 우선)
│ elem: 2     │
│ counts:[1]  │
└─────────────┘

** 동일 상태 = 동일 미래 → 하나만 추적해도 충분 **
```

### 4.3 counts[] 리셋 규칙

```
리셋 타이밍:
┌────────────────────────┬─────────────────┬─────────────────────┐
│         상황           │   리셋 범위     │        설명         │
├────────────────────────┼─────────────────┼─────────────────────┤
│ depth N에서 jump       │ counts[N+1:]    │ 내부 그룹만 리셋    │
│ depth N에서 next       │ 리셋 없음       │ 그룹 완료, 진행     │
│ 새 컨텍스트 생성       │ 전체 0 초기화   │ 새 시작             │
└────────────────────────┴─────────────────┴─────────────────────┘

예: ((A B){2,3} C) 에서 그룹 종료[2] 도달 시

counts[1] = 1 (첫 번째 AB 완료):
  → 1 < min(2) → 반드시 jump
  → counts[1] 유지, 내부(counts[2:]) 리셋

counts[1] = 2 (두 번째 AB 완료):
  → 2 >= min(2), 2 < max(3) → fork (jump와 next 둘 다)
  → jump 경로: counts[1]=2 유지
  → next 경로: C로 진행

counts[1] = 3 (세 번째 AB 완료):
  → 3 == max(3) → 반드시 next
  → C로 진행
```

---

## 5. 실행 예제

### 5.1 단순 시퀀스: `PATTERN (A B+ C)`

```
입력 데이터:
┌─────┬───┬───┬───┐
│ row │ A │ B │ C │
├─────┼───┼───┼───┤
│  0  │ T │ F │ F │
│  1  │ F │ T │ F │
│  2  │ F │ T │ F │
│  3  │ F │ F │ T │
└─────┴───┴───┴───┘

실행 과정:

[Row 0] A=T 매칭
  Context 생성 (match_start: 0)
  State: elem=1(B대기), counts=[1]

  ┌─────────────────────────────────────┐
  │ Context 0 (match_start: 0)          │
  │   State: elem=1, counts=[1]         │
  └─────────────────────────────────────┘

[Row 1] B=T 매칭
  State 진행: elem=1(B), counts=[2]

  ┌─────────────────────────────────────┐
  │ Context 0 (match_start: 0)          │
  │   State: elem=1, counts=[2]         │
  └─────────────────────────────────────┘

[Row 2] B=T 매칭
  State 진행: elem=1(B), counts=[3]

  ┌─────────────────────────────────────┐
  │ Context 0 (match_start: 0)          │
  │   State: elem=1, counts=[3]         │
  └─────────────────────────────────────┘

[Row 3] C=T 매칭
  B 불만족, min 충족 → C로 전이 가능
  State 진행: elem=-1(완료)
  match_end = 3

  ┌─────────────────────────────────────┐
  │ Context 0 (match_start: 0) ★ 완료   │
  │   match_end: 3                      │
  │   State: elem=-1 (완료)             │
  └─────────────────────────────────────┘

결과 출력:
  매칭 범위: row 0 ~ row 3

  MEASURES 계산 시 재스캔:
    row 0: DEFINE A 만족 → A
    row 1: DEFINE B 만족 → B
    row 2: DEFINE B 만족 → B
    row 3: DEFINE C 만족 → C

  COUNT(B.*) = 2
  FIRST(A.value) = row 0의 value
  LAST(B.value) = row 2의 value
```

### 5.2 대안선택과 Merge: `PATTERN ((A B) | (C B)) D`

```
입력 데이터:
┌─────┬───┬───┬───┬───┐
│ row │ A │ B │ C │ D │
├─────┼───┼───┼───┼───┤
│  0  │ T │ F │ T │ F │  ← A, C 둘 다 매칭
│  1  │ F │ T │ F │ F │  ← B 매칭
│  2  │ F │ F │ F │ T │  ← D 매칭
└─────┴───┴───┴───┴───┘

실행 과정:

[Row 0] A=T, C=T (둘 다 매칭 → Fork)
  State 1: A 경로 시작
  State 2: C 경로 시작

  ┌─────────────────────────────────────────────┐
  │ Context 0 (match_start: 0)                  │
  │   State 1: elem=1(B대기), counts=[0,1]      │
  │   State 2: elem=4(B대기), counts=[0,1]      │
  └─────────────────────────────────────────────┘

[Row 1] B=T (두 경로 모두 B 매칭)
  State 1: B 매칭 → 그룹종료 → elem=5(D대기)
  State 2: B 매칭 → elem=5(D대기)

  ** 두 상태가 동일해짐: elem=5, counts=[0,0] **
  ** → Merge! 첫 번째(A→B 경로) 유지 **

  ┌─────────────────────────────────────────────┐
  │ Context 0 (match_start: 0)                  │
  │   State (merged): elem=5, counts=[0,0]      │
  └─────────────────────────────────────────────┘

[Row 2] D=T
  State: D 매칭 → 완료
  match_end = 2

  ┌─────────────────────────────────────────────┐
  │ Context 0 (match_start: 0) ★ 완료           │
  │   match_end: 2                              │
  └─────────────────────────────────────────────┘

결과 출력:
  매칭 범위: row 0 ~ row 2

  MEASURES 계산 시 재스캔:
    row 0: DEFINE A 만족 → A (또는 C, 둘 다 만족 시 첫 번째 선택)
    row 1: DEFINE B 만족 → B
    row 2: DEFINE D 만족 → D
```

### 5.3 그룹 반복: `PATTERN ((A B){2,3} C)`

```
입력 데이터:
┌─────┬───┬───┬───┐
│ row │ A │ B │ C │
├─────┼───┼───┼───┤
│  0  │ T │ F │ F │
│  1  │ F │ T │ F │  ← 첫 번째 AB 완료
│  2  │ T │ F │ F │
│  3  │ F │ T │ F │  ← 두 번째 AB 완료, Fork!
│  4  │ F │ F │ T │
└─────┴───┴───┴───┘

실행 과정:

[Row 0] A=T
  State: elem=1(B대기), counts=[0,1]

[Row 1] B=T → 그룹종료[2] 도달
  counts[1]=1 < min(2) → 반드시 jump
  State: elem=0(A대기), counts=[0,1]

[Row 2] A=T
  State: elem=1(B대기), counts=[0,2]

[Row 3] B=T → 그룹종료[2] 도달
  counts[1]=2 >= min(2), < max(3) → Fork!

  ┌─────────────────────────────────────────────────────────┐
  │ Fork 발생!                                              │
  │                                                         │
  │   State 1 (jump - 반복):                                │
  │     elem=0(A대기), counts=[0,2]                         │
  │                                                         │
  │   State 2 (next - 진행):                                │
  │     elem=3(C대기), counts=[0,0] ← counts[1] 리셋        │
  └─────────────────────────────────────────────────────────┘

[Row 4] C=T
  State 1: A 불만족, 하지만 counts[1]=2 >= min → C 체크
           C=T → 완료!
  State 2: C=T → 완료!

  ** 두 상태 모두 완료 → 동일 결과 **

결과 출력:
  매칭 범위: row 0 ~ row 4

  MEASURES 계산 시 재스캔:
    row 0: A
    row 1: B
    row 2: A
    row 3: B
    row 4: C

  그룹 AB 반복 횟수: 2회
```

---

## 6. MEASURES 계산 방식

### 6.1 재스캔 기반 계산

```
┌────────────────────────────────────────────────────────────────────┐
│  매칭 완료 후:                                                     │
│    match_start = 0                                                 │
│    match_end = 4                                                   │
│                                                                    │
│  MEASURES 계산:                                                    │
│    for row in match_start..match_end:                              │
│        for each var in pattern_variables:                          │
│            if DEFINE[var] evaluates to true for row:               │
│                assign row to var                                   │
│                break                                               │
│                                                                    │
│  집계 함수 계산:                                                   │
│    COUNT(B.*) = B에 할당된 행 수                                   │
│    SUM(B.value) = B에 할당된 모든 행의 value 합                    │
│    AVG(B.value) = B에 할당된 모든 행의 value 평균                  │
│    FIRST(B.value) = B에 할당된 첫 행의 value                       │
│    LAST(B.value) = B에 할당된 마지막 행의 value                    │
└────────────────────────────────────────────────────────────────────┘
```

### 6.2 예제: SUM, AVG 계산

```
PATTERN (A B+ C)
DEFINE A AS value < 10,
       B AS value >= 10 AND value < 50,
       C AS value >= 50
MEASURES SUM(B.value) AS b_sum, AVG(B.value) AS b_avg

입력 데이터:
┌─────┬───────┐
│ row │ value │
├─────┼───────┤
│  0  │   5   │  → A (5 < 10)
│  1  │  20   │  → B (10 <= 20 < 50)
│  2  │  30   │  → B (10 <= 30 < 50)
│  3  │  60   │  → C (60 >= 50)
└─────┴───────┘

매칭 완료: match_start=0, match_end=3

MEASURES 계산:
  재스캔으로 각 행의 변수 결정:
    row 0: A
    row 1: B (value=20)
    row 2: B (value=30)
    row 3: C

  SUM(B.value) = 20 + 30 = 50
  AVG(B.value) = 50 / 2 = 25
```

### 6.3 FIRST, LAST, COUNT 계산

```
MEASURES
  FIRST(B.value) AS first_b,
  LAST(B.value) AS last_b,
  COUNT(B.*) AS b_count

재스캔 결과:
  B 행들: [row 1 (value=20), row 2 (value=30)]

  FIRST(B.value) = 20 (첫 번째 B 행)
  LAST(B.value) = 30 (마지막 B 행)
  COUNT(B.*) = 2 (B 행 개수)
```

---

## 7. 컨텍스트 흡수

### 7.1 문제: 컨텍스트 폭발

```
패턴: A+
모든 행이 A=T인 경우:

Row 0: Context 0 생성 (start:0)
Row 1: Context 0 진행, Context 1 생성 (start:1)
Row 2: Context 0,1 진행, Context 2 생성 (start:2)
...
Row N: N개의 컨텍스트 존재 → O(N) 메모리!

┌──────────────────────────────────────────────────────────┐
│ Row 3 상태:                                              │
│                                                          │
│ Context 0 (start:0): counts=[4] ← 가장 앞선 상태        │
│ Context 1 (start:1): counts=[3] ← Context 0이 지나간 곳 │
│ Context 2 (start:2): counts=[2] ← Context 0이 지나간 곳 │
│ Context 3 (start:3): counts=[1] ← Context 0이 지나간 곳 │
└──────────────────────────────────────────────────────────┘
```

### 7.2 해결: 흡수

```
흡수 원리:
- Context 0이 counts=[4]에 있다면,
- 이전에 counts=[3], [2], [1]을 모두 거쳐왔음
- 따라서 뒤의 컨텍스트들은 불필요 (같은 미래)

흡수 후:
┌──────────────────────────────────────────────────────────┐
│ Row 3 상태:                                              │
│                                                          │
│ Context 0 (start:0): counts=[4] ← 이것만 유지           │
│ [Context 1, 2, 3 흡수됨]                                 │
└──────────────────────────────────────────────────────────┘

메모리: O(N) → O(1)
```

### 7.3 흡수 조건

```
┌─────────────────────────┬────────────┐
│         조건            │  흡수 가능 │
├─────────────────────────┼────────────┤
│ SKIP PAST LAST ROW      │     O      │
│ SKIP TO NEXT ROW        │     X      │  (모든 매칭 필요)
│ max = ∞ (*, +)          │     O      │
│ max = 유한 ({n,m}, ?)   │     X      │  (앞 컨텍스트가 먼저 종료)
└─────────────────────────┴────────────┘
```

---

## 8. SKIP 옵션

### 8.1 SKIP PAST LAST ROW (기본값)

```
패턴: A B+
입력: A B B A B

┌─────┬───┬───┐
│ row │ A │ B │
├─────┼───┼───┤
│  0  │ T │ F │  ← Context 0 시작
│  1  │ F │ T │
│  2  │ F │ T │
│  3  │ T │ F │  ← Context 0 완료, 매칭 범위: 0~2
│  4  │ F │ T │     새 Context 1 시작 (row 3부터)
└─────┴───┴───┘

결과: 1개 매칭 (row 0~2)
     row 3~4도 별도 매칭 가능 (A B)
```

### 8.2 SKIP TO NEXT ROW

```
패턴: A B+
입력: A B B

┌─────┬───┬───┐
│ row │ A │ B │
├─────┼───┼───┤
│  0  │ T │ F │  ← Context 0 시작
│  1  │ T │ T │  ← Context 0 진행, Context 1 시작
│  2  │ F │ T │
│  3  │ F │ F │  ← 두 컨텍스트 모두 완료
└─────┴───┴───┘

결과: 2개 매칭
  - Context 0: row 0~2 (A B B)
  - Context 1: row 1~2 (A B)  ← 중첩 허용
```

---

## 9. 복잡도

### 9.1 시간 복잡도

| 연산 | 평균 | 최악 |
|------|------|------|
| 행 처리 | O(S × E) | O(S² × E) |
| 상태 Fork | O(depth) | O(depth) |
| 상태 Merge | O(1) | O(depth) |
| 컨텍스트 흡수 | O(C² × S) | O(C² × S × depth) |
| MEASURES 재스캔 | O(match_length × V) | - |

- S: 동시 상태 수
- E: 패턴 요소 수
- C: 컨텍스트 수
- V: 변수 개수
- depth: 최대 중첩 깊이

### 9.2 공간 복잡도

| 구성 요소 | 복잡도 |
|-----------|--------|
| Pattern | O(E) |
| MatchState | O(depth) |
| 전체 런타임 | O(C × S × depth) |

**History 제거 효과:**
- 기존: O(C × S × depth + H), H = 총 히스토리 노드 수
- 현재: O(C × S × depth) - 히스토리 노드 없음

### 9.3 Trade-off: History vs 재스캔

```
┌─────────────────────────┬──────────────────┬──────────────────┐
│                         │   History 방식   │   재스캔 방식    │
│                         │  (Flink 스타일)  │   (본 설계)      │
├─────────────────────────┼──────────────────┼──────────────────┤
│ NFA 상태 메모리         │ O(매칭 행 수)    │ O(1)             │
│ Fork 비용               │ O(1) 포인터      │ O(depth) 배열    │
│ MEASURES 계산           │ 히스토리 역추적  │ 원본 재스캔      │
│ 구현 복잡도             │ 높음             │ 낮음             │
│ 메모리 관리             │ 참조 카운트 필요 │ 불필요           │
│ 원본 데이터             │ 저장 불필요      │ 머티리얼라이즈   │
└─────────────────────────┴──────────────────┴──────────────────┘
```

### 9.4 Apache Flink의 History 방식

```
┌────────────────────────────────────────────────────────────────────┐
│  CEP/스트리밍 환경의 특성:                                         │
│                                                                    │
│    row 0 도착 → 처리 → 버려짐 (저장하지 않음)                      │
│    row 1 도착 → 처리 → 버려짐                                      │
│    row 2 도착 → 처리 → 버려짐                                      │
│    ...                                                             │
│    매칭 완료 → 원본 데이터 없음!                                   │
│             → History에 저장해둔 정보로 SUM/AVG 계산               │
│                                                                    │
│  Apache Flink의 SharedBuffer:                                      │
│    - 스트리밍이므로 원본 레코드를 유지하지 않음                    │
│    - 매칭 중에 각 행의 정보를 History 노드로 기록                  │
│    - 포인터 트리로 여러 상태가 공유 → 메모리 효율화                │
│    - MEASURES 계산 시 History 역추적                               │
└────────────────────────────────────────────────────────────────────┘
```

### 9.5 본 설계의 재스캔 방식

```
┌────────────────────────────────────────────────────────────────────┐
│  PostgreSQL MATCH_RECOGNIZE:                                       │
│                                                                    │
│    PARTITION/ORDER BY 결과를 머티리얼라이즈 (tuplestore)           │
│    매칭 완료 → match_start=0, match_end=3                          │
│             → 머티리얼라이즈된 데이터에서 row 0~3 재스캔           │
│             → DEFINE 재적용하여 변수 결정                          │
│             → SUM, AVG 계산                                        │
│                                                                    │
│  특징:                                                             │
│    - NFA 상태에 History 불필요 → 구현 단순                         │
│    - 단, 원본 데이터 머티리얼라이즈 필요 → 공간 비용               │
└────────────────────────────────────────────────────────────────────┘
```

### 9.6 환경별 비교

| 환경 | 원본 데이터 | History | MEASURES 계산 |
|------|-------------|---------|---------------|
| Apache Flink (CEP) | 저장 안 함 | **필요** | History 역추적 |
| Esper (CEP) | 저장 안 함 | **필요** | 배열 복사 방식 |
| PostgreSQL (본 설계) | 머티리얼라이즈 | 불필요 | 범위 재스캔 |

### 9.7 향후 개선 방향: SUM/AVG 최적화

```
┌────────────────────────────────────────────────────────────────────┐
│  현재 방식의 한계:                                                 │
│    - 머티리얼라이즈로 인한 공간 비용                               │
│    - 긴 매칭 범위에서 재스캔 비용                                  │
│                                                                    │
│  개선 방향 (선택적):                                               │
│    1. History 포인터 트리 도입 (Flink 방식)                        │
│       - 머티리얼라이즈 없이 SUM/AVG 계산 가능                      │
│       - 구현 복잡도 증가, 참조 카운트 관리 필요                    │
│                                                                    │
│    2. 증분 집계 (Incremental Aggregation)                          │
│       - 매칭 중에 running_sum, running_count 유지                  │
│       - 매칭 완료 시 즉시 계산 가능                                │
│       - Fork 시 집계 값도 복사 필요                                │
│                                                                    │
│  현재는 구현 단순성을 우선하여 재스캔 방식 채택                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## 10. 안전 제한

### 10.1 제한값

| 제한 | 기본값 | 설명 |
|------|--------|------|
| MAX_CONCURRENT_STATES | 1,000 | 동시 상태 수 |
| MAX_CONCURRENT_CONTEXTS | 10,000 | 동시 컨텍스트 수 |
| MAX_PATTERN_ELEMENTS | 100 | 패턴 요소 수 |
| MAX_PATTERN_DEPTH | 10 | 최대 중첩 깊이 |

### 10.2 통계 수집

| 통계 | 설명 | 진단 |
|------|------|------|
| states_created | 생성된 상태 수 | - |
| states_merged | 병합된 상태 수 | 높으면 정상 |
| max_concurrent_states | 최대 동시 상태 | 높으면 패턴 복잡 |
| contexts_absorbed | 흡수된 컨텍스트 | 높으면 흡수 작동 중 |
| hash_comparisons | 해시 비교 횟수 | - |
| full_comparisons | 전체 비교 횟수 | 높으면 해시 충돌 |

---

## 11. 요약

### 11.1 핵심 자료구조 (단순화됨)

```
Pattern ─────────────▶ PatternElement[] (플랫 배열)
    │
    ▼
NFAExecutor
    │
    ├──▶ Context ───▶ Context ───▶ ...
    │        │
    │        ├─ match_start
    │        ├─ match_end
    │        │
    │        ▼
    │    MatchState ───▶ MatchState ───▶ ...
    │        │
    │        ├─ element_index
    │        └─ counts[]
    │
    └──▶ StatePool (재사용)

** History 없음 - match_start/match_end로 충분 **
```

### 11.2 설계 특징

| 항목 | 설명 |
|------|------|
| 플랫 배열 패턴 | 캐시 효율, 단순한 전이 |
| 해시 기반 상태 비교 | O(1) Merge |
| 컨텍스트 흡수 | O(N) → O(1) 메모리 |
| 상태 풀 | 할당 오버헤드 감소 |
| 재스캔 기반 MEASURES | History 없이 구현 단순화 (머티리얼라이즈 기반) |

### 11.3 지원 기능

| 기능 | 상태 |
|------|------|
| 수량자 (?, *, +, {n,m}) | 지원 |
| 대안선택 (\|) | 지원 |
| 그룹 반복 | 지원 |
| 중첩 그룹 | 지원 |
| SKIP PAST LAST ROW | 지원 |
| SKIP TO NEXT ROW | 지원 |
| 일반 윈도우 함수 (first_value, last_value, count 등) | 지원 |
| RELUCTANT | 확장 예정 |
| PERMUTE | 확장 예정 |

### 11.4 설계 핵심 결정

```
┌────────────────────────────────────────────────────────────────────┐
│  History 불필요 결정 근거:                                         │
│                                                                    │
│  1. match_start, match_end만 있으면 매칭 범위 확정                 │
│  2. 원본 데이터를 머티리얼라이즈하여 재스캔 가능                   │
│  3. DEFINE 조건 재적용으로 각 행의 변수 결정 가능                  │
│  4. SUM, AVG, COUNT, FIRST, LAST 모두 재스캔으로 계산 가능         │
│                                                                    │
│  장점:                                                             │
│  - NFA 상태 구조 단순화                                            │
│  - 구현 복잡도 감소 (포인터 트리, 참조 카운트 불필요)              │
│  - Fork 시 counts[] 배열만 복사 (단순)                             │
│  - GC 관련 버그 가능성 제거                                        │
│                                                                    │
│  트레이드오프:                                                     │
│  - 원본 데이터 머티리얼라이즈 필요 (공간 비용)                     │
│  - 긴 매칭 범위에서 재스캔 비용                                    │
└────────────────────────────────────────────────────────────────────┘
```

---

## 12. 향후 확장: SQL 표준 MEASURES 절

```sql
-- SQL 표준 MEASURES (현재 미구현)
MEASURES
  SUM(B.value) AS b_sum,
  FIRST(A.price) AS a_price
```

현재는 일반 윈도우 함수(`first_value`, `last_value`, `count` 등)를 사용합니다.
MEASURES 구현 시에도 재스캔 기반으로 동일하게 처리 가능합니다.
